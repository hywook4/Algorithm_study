========
연산 시, 그 연산의 값은 해당 자료형 크기에 저장된다 ㅠㅜ

예를 들어서 
int a, b;
long long c = a*b; 할때도 
만약 a*b값이 이미 int를 넘어서버리면 오버플로우 된 값이
들어가버리기 때문에 캐스팅을 해주던가
a, b 자체를 long long으로 선언해줘야됨 ㅠㅜ
후...

========

나머지에 관한 성질.

특정 수 n과 a가 존재하고 n^l%a를 구하고자 할때, 
그때그때 나머지에 다시 n을 곱해서 a의 나머지를 구해도 
같다

이유는 다음과 같다. n을 a의 곱 형태로 나타내자면

n = ax + b 이다. 이때 b를 나머지로 두자. 

그럼 이번엔 n^2을 보자. 

(ax + b)n 를 a로 나눴을때의 나머지를 구해보면,
우선 anx + bn 이 나오는데, 결국 anx는 무조건 a로 나누어
떨어지기 때문에, bn을 a로 나누고 나머지만 구하면 된다.

결국 나머지에 n을 곱해서 다시 구한 a에 대한 나머지는 같아진다.

========

진짜 멍청한 실수 ***** 근데 엄청 중요한거

함수의 리턴형을 long long으로 해두고 int 형을 return하게 되면
매우 문제가 생겨버린다... 꼭 명심하기! 항상 리턴형은 맞추자... 제발

========

이것도 항상 실수 자주나오는거. 출력하는 값이 얼마나 커질 수 
있을지 생각해보기. 꼭 int 범위 내로 안되서 overflow나서
틀리는 경우 꽤있음

========

위의 실수랑 비슷한거. dp 시에, 현재 값에서 미래 값을 계산할때,
그 다음 계산되는 dp의 값이 얼마나 커지는지, 혹은 어느 범위까지
가는지 잘 생각해서 배열 크기 선언하기. 
혹은 원하는 값보다 커지면 그냥 무시하는 것도 방법

========

or 인지 and 인지 확실하게 생각해서 쓰기....
or 해야되는걸 and 해서 틀리는 경우가 있다... 집중하자

========

이진 탐색 문제에서 left, right을 정할 때 좀
고려해야하는 문제들이 있는거 같다.
가령 mid = (left+right)/2 이고
만약 내가 특정 값을 mid로 나눈 값을 써야하는 경우가 있을때,
mid가 0이 되는 경우 당연히 런타임 에러가 뜰 것이다.

결국 => 0으로 나눠지는 경우 조심하기

========
